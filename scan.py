'''usage: python scan.py'''

# import the necessary packages
import argparse
import cv2
import json
import numpy as np
from pyzbar import pyzbar
import os
import shutil
import sys
from enum import Enum

import utils


def parse_args():
  # construct the argument parser and parse the arguments
  ap = argparse.ArgumentParser()
  ap.add_argument("-w", "--walklist", default=utils.TEMP_DIR,
    help="path to temp directory generated by preprocess.py.")
  ap.add_argument("--rotate_dir", default='CW', 
    help="CW or CCW, rotate the page 90 degrees")
  return vars(ap.parse_args())


""" Returns (barcode_coords, voter_id)"""
def extract_barcode_info(barcode, image):
  data = barcode.data.decode("utf-8")    
  voter_id = data[-3]  # remove the CA at the end
  
  (x, y, w, h) = barcode.rect
  barcode_coords = ((x, y), (x + w, y + h))

  # draw image
  if utils.__DEBUG__:
    # extract the the barcode
    pts = np.array([[[x, y] for (x, y) in barcode.polygon]], np.int32)
    cv2.polylines(image, pts, True, (0, 0, 255), 2)
    # cv2.rectangle(image, (x, y), (x + w, y + h), (0, 0, 255), 2)

    # the barcode data is a bytes object so if we want to draw it on
    # our output image we need to convert it to a string first
    # draw the barcode data and barcode type on the image
    text = "{}".format(data)
    cv2.putText(image, text, (x, y - 10), cv2.FONT_HERSHEY_SIMPLEX,
      0.5, (0, 0, 255), 2)

    # print the barcode type and data to the terminal
    print("[INFO] Found barcode: {}".format(barcode))

  return barcode_coords, voter_id


def get_voter_id(image, bounding_box):
  text = run_ocr(image, bounding_box)
  print(text)
  voter_id = text.split(' ')[0]

  if utils.__DEBUG__:
    print ("voter_id: ", voter_id)

  return voter_id


def get_response_roi_for_barcode(barcode_coords, first_response_coords):
  response_h = first_response_coords[1][1] - first_response_coords[0][1]
  return ((first_response_coords[0][0], barcode_coords[0][1]),
          (first_response_coords[1][0], barcode_coords[0][1] + response_h))


# Returns a list of circled response codes.
def get_circled_responses(response_roi, answer_coordinates):
  # carve out the roi
  # threshold
  # ret, image = cv2.threshold(image, 140, 255, cv2.THRESH_BINARY_INV)
  # Diff
  # centroiding
  # Match to responses
  return None


# TODO(jeff): fill this out
def save_responses(responses, voter_id, list_id):
  pass
  # filename = "%s.csv" % list_id
  # for response in responses:
  #   pass
  # pass


def main():
  args = parse_args()
  ref_bounding_boxes = utils.load_ref_boxes()

  # TODO: Replace with number of pages in the folder by default
  # and allow passing in page to start from 
  for page_number in range(2):
    page = utils.load_page(page_number, args["rotate_dir"])
    response_codes = utils.load_response_codes()
    list_id = utils.get_list_id(page, ref_bounding_boxes["list_id"])

    # find the barcodes in the image and decode each of the barcodes
    barcodes = pyzbar.decode(page)

    # loop over the detected barcodes
    for barcode in barcodes:
      (barcode_coords, voter_id) = extract_barcode_info(barcode, page)

      # Get the corresponding response codes region
      response_roi = get_response_roi_for_barcode(barcode_coords,
                                                  ref_bounding_boxes["first_response_codes"])
      cv2.rectangle(page, response_roi[0], response_roi[1], (0, 0, 255), 2)

      # Figure out which ones are circled
      responses = get_circled_responses(response_roi, response_codes)

      # Save to CSV
      save_responses(responses, voter_id, list_id)

    utils.show_image(page)

    # if utils.__DEBUG__:
    # box = box_dict_to_tuples(ref_bounding_boxes["first_voter_id"])
    # # print (ref_bounding_boxes["first_response_codes"])
    # cv2.rectangle(page, box[0], box[1], (0, 0, 255), 1)


if __name__ == '__main__':
  main()


